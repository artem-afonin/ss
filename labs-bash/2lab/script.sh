#!/usr/bin/env bash

MY_DIR=$(dirname $(readlink -m "$0"))


# 1. Определить тип используемой командной оболочки.

# $SHELL --version


# 2. Вывести на экран значения всех переменных среды окружения.
# Проанализировать полученные результаты и объяснить значения известных вам переменных окружения.

# env | sort


# 3. Используя процедуру экспортирования изменить приглашение командной строки так,
# чтобы в основном приглашении имя машины выводилось
# красным цветом, а в приглашении для второй строки выводился номер
# команды и символ ''>''.

# TODO


# 4. Используя системную переменную HOME и список команд выполнить
# следующие действия: одной командой -- перейти в домашний каталог, в
# случае удачного перехода выдать содержимое файла /etc/passwd.

# cd $HOME
# if [[ "$?" == "0" ]]; then
#     cat /etc/passwd
# fi

# cd $HOME && cat /etc/passwd


# 5. Используя команды printf и read, выведете приглашение пользователю
# ввести команду. Если пользователь нажал <ENTER> без ввода команды,
# сообщить ему об ошибке, в противном случае выполнить то, что он ввел.

# printf "Please enter cmd: "
# read CMD
# if [[ -n "$CMD" ]]; then
#     $CMD
# fi


# 6. Оформите предыдущий пункт как скрипт и выполните его.

# echo \
# '#!/usr/bin/env bash
# printf "Please enter cmd: "
# read CMD
# if [[ -n "$CMD" ]]; then
#     $CMD
# fi
# ' > ${MY_DIR}/test_script.sh
# chmod 755 ${MY_DIR}/test_script.sh
# ${MY_DIR}/test_script.sh


# 7. Вывести значения всех переменных среды окружения в файл с именем \~/envs.

# env | sort | sed -rn 's|[^=]+=||p' >${MY_DIR}/envs
# rm -f ${MY_DIR}/envs


# 8. Используя системную переменную HOME, список, каналы и перенаправление вывода,
# выполнить следующие действия одной командой - перейти в домашний каталог,
# выдать содержимое файла /etc/passwd, отсортированное по имени пользователя в файл passwd.orig.

# cd $HOME && cat /etc/passwd | sort -t ":" -k 1 >${MY_DIR}/passwd.orig


# 9. Используя перенаправление ввода с разделителем и перенаправление вывода,
# добавить в файл passwd.orig информацию о себе согласно формату записи файла /etc/passwd
# (все поля должны быть обязательно заполнены).

# TODO:


# 10. Описать содержимое файла ~/.bash_profile и всех файлов, которые он использует.

# TODO:


# 11. Написать скрипт, выполняющий следующие действия:
# выводит меню, содержащее все файлы с расширением .c текущего каталога.
# После выбора пользователем файла, компилирует его.

# refers to gcc-interface.sh


# 12. Написать скрипт, анализирующий параметры командной строки с использованием специальных переменных.
# Все параметры должны быть выданы на экран.

# echo "Parameters passed:  $#"
# echo "Parameters str raw: \"$*\""
# let "COUNTER=1"
# for PARAM in $@; do
#     echo "Param $COUNTER is $PARAM"
#     let "COUNTER+=1"
# done
# unset COUNTER


# 13. Написать скрипт, анализирующий параметры командной строки.
# Параметры должны быть следующие - -d каталог, -f файл, -c, -r.
# При анализе опций должны быть установлены переменные: DIR, FILE, COMPIL, RUN.
# Поле анализа опций выполнить следующие действия: если определена
# переменная DIR и такой каталог существует, то выдать его содержимое.
# Если определена переменная FILE и такой файл существует, то выдать
# его содержимое на экран. Если переменная не определена, то в качестве
# имени файла использовать .bashrc. Если определена переменная COMPIL
# и определена переменная FILE, то откомпилировать указанный файл.
# Если результат компиляции положительный, то, если определена переменная RU, исполнить откомпилированный файл.

# TODO:


# 14. Используя цикл for объединить все файлы с расширением txt в текущем
# каталоге в файл \~/textx.txt. Для объединения использовать перенаправление потоков ввода-вывода.

# cat *.txt >${MY_DIR}/textx.txt
